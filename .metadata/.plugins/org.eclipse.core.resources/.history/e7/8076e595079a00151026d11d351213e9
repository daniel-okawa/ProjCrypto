package src.algorithms;

public class AES {
	
	private int keySize = 128;
	private int Nb = 4;
	private int Nk = keySize / 32;
	private int Nr = Nk + 6;
	
	private byte[] inputArray = new byte[4 * Nb];
	private byte[] outputArray = new byte[4 * Nb];
	private byte[] word = new byte [Nb * (Nr + 1)];
	private byte[] stateArray = new byte[4 * Nb];
	
	
	public AES(String mode){
		if (mode == "ECB"){
			
		}
		else if (mode == "CBC"){
			
		}
		else if (mode == "CTR"){
			
		}
		

	}
	
	public void interfaceAES(){
		aes_encrypt();
	}
	
	private void aes_encrypt(){
		//Copia a input para o state
		stateArray = inputArray.clone();
		addRoundKey(stateArray, word[0][Nb - 1]);
		
		for (int round = 1; round < Nr -1; round++){
			subBytes(stateArray);
			shiftRows(stateArray);
			mixColumns(stateArray);
			addRoundKey(stateArray, word[round * Nb][(round + 1) * Nb - 1]);
		}
		
		subBytes(stateArray);
		shiftRows(stateArray);
		addRoundKey(stateArray, word[Nr * Nr][(Nr + 1) * Nb - 1]);
		
		outputArray = stateArray.clone();
		System.out.println("Output: " + outputArray);
	}
	
	private void subBytes(byte[] stateArray){}
	
	private void shiftRows(byte[] stateArray){}
	
	private void mixColumns(byte[] stateArray){}
	
	private void subWord(byte[][] temp){}
	
	private void keyExpansion(byte[] key, byte[] word){
		byte[] temp;
		int i;
		for(i = 0; i < Nb; i++){
			for(int j = 0; j < Nk; j++){
				word[4 * i + j] = key[j];
			}
		}
		
		i = Nk;
		
		while (i < Nb * (Nr + 1)){
			temp = word[i - 1];
			if (i % Nk == 0){
				temp = subWord(temp);
			}
		}
		
	}
	
	private void addRoundKey(byte[] stateArray, byte word){
		int i = 0;
		for (byte b : stateArray){
		    stateArray[i] = (byte) (b^ word);
			System.out.println(stateArray[i]);
		}
	}
	

}
